Python Crash Course Notes

Naming convention:
- variables: lowercase, must begin with underscore or letter, labels assigned to values
- constants: all caps

Variable types:
- string: series of characters inside quotation marks ("" or '' where choice based on whether ' or " used within string)
	- f-string: use f"{}" to insert variable into string, can type in strings and use methods, previously format() method
- integer: use _ to improve readability
- float: given in any operation involving a float or division, use _ to improve 

Lists: 
- collection of items in a particular order
- example_list = [x, y]
- index: starts at 0, -1 is last, example_list[0].title() to access item and change capitalisation
- slicing: use list[index1:index2:step] to get a portion of the list, use list[:] to copy full list (lists not separate if simply equated!)

Tuples:
- immutable lists
- example_tuple = (x, y) and defined by commas so must always include a comma (even if one element only)
- use standard index notation []

Dictionaries:
- collections of key-value pairs where any object in python can be a value
- example_dictionary = {'att1': 'value1', 'att2':, 'value2'}
- to access a value: dictionary[key]
- to add or modify a key-value pair: dictionary[key] = value
- order of key-value pairs retained
- when used with user input: dictionary[key] = [value]

Nesting:
- storing dictionaries in a list, or storing a list in a dictionary, or storing a dictionary in a dictionary
- avoid nesting too deeply

Sets:
- collection of items in which each item is unique
- example_set = {'a', 'b', 'c'}
- example_set = set(list)
- items not retained in a specific order
- if repeat placed into a set, repeat is ignored and removed

Methods:
- actions python performs on a piece of data
- variable.method()
- .title(), .lower(), .upper() to change case
- .rstrip(), .lstrip(), .strip() to remove whitespace around string
- .append(value), .insert(index, value), .pop(index), .remove(value) to edit lists where remove(value) only removes first occurence
- .sort(reverse=), .reverse() to permanently organise lists
- .get(key, optional value) to get dictionary values if key may not exist
- .items(), .keys(), .values() to return list of key-value pairs, keys and values in a dictionary, used with loops where .keys() is default
- .isnumeric() to check if all characters in a string are numeric

Functions:
- blocks of code designed to do one specific job
- def function(input): called function definition
- to call a function, type write its name with necessary input
- code with functions easier to maintain and extend
- parameter: piece of information the function requires, defined as a variable
	- can set a default value in function definition with mandatory parameters first
	- use parameter='' or parameter=None or parameter=0 to indicate optional parameter
	- use *parameter for args to be stored in an empty tuple, allowing for an arbitrary number of args, must be defined last
	- use **parameter to create a dictionary and store all key-value arguments in it
- argument: piece of information passed to the function call, specific data value
	 - positional: order in function definition matched to order in function call, order matters
	 - keyword: name-value pair passed to a function, order irrelevant
	 - arbitrary: not pre-defined, pass as a tuple using *parameter (*args) or key-value pairs as **parameter (**kwargs)
	 - lists and dictionaries, feed in list[:] to use a copy of list, more efficient to use original list
- return value: value returned by function, use return statement, can return any data entity
- use modules to store functions in a separate file, use import statements
	- should be defined at the start of the file, can use alias to shorter function name
	- to import an entire module: import module_name or import module_name as mn
		- call functions using module_name.function_name() if not imported specific functions
	- to import all or specific functions from a module: 
		- from module_name import * (this can lead to module functions overwriting existing functions - not recommended)
		- from module_name import function_0, function_1 or from module_name import function_name as fn
		- call functions using function_name()
- commonly used inbuilt functions:
	- del(obj_name) to delete an object (incl. dictionary key-value pairs, list items)
	- sorted(list, reverse=) to temporarily sort lists alphabetically or numerically
	- range(first value, final value+1, step) in for loops, stops at final value so never prints it, range(6) gives 0-5
	- list() to create lists, e.g. list(range(5))
	- min(list) to give smallest value
	- max(list) to give largest value
	- sum(list) to give sum of all values
	- set(list) to give a unique collection of values in list
	- input(prompt) to obtain user input in string format
	- int(string) to convert a string to numerical format
	- break to exit any loop immediately
	- continue to skip rest of while loop and go back to the start
	- return to return a value in a function, provide a variable to assign return value to
	- __init__(self, par1, par2), to initialise parameters in classes

Formatting:
- \t for tab
- \n for new line
- """x""" for documenting code, called doctring

Conditional tests (Boolean expressions):
- = for assigning
- == for checking equality (equality operator)
- != for checking inequality
- <, <=, >, >= for mathematical comparisons
- in for checking whether value in a list
- not in for checking whether value not in a list
- non-empty string evaluates as True
- None evaluates as False

Other:
- multiple assignment: e.g. x, y, z = 0, 0, 0
- modulo operator: returns remainder, e.g. 4 % 3 returns 1
- += operator is equivalent to x = x + a

Loops:
- for loop: use : and indentation
	- dictionaries: for key, value, in sorted/set(dictionary.items()/keys()/values()):
	- shouldn't use for loops to midfy lists and dictionaries, use while loops instead
- list comprehension allows to create lists in one line, [expression for loop] e.g. squares = [value**2 for value in range(1,11)]
- if loop: use : and indentation
	- uses conditional tests (True or False)
	- case sensitive, use item.lower() == 'x' for testing
	- and / or for checking for multiple conditions
	- if, elif, else, run multiple if statements if each test needs to be evaluated / acted on
	- if list: checks if list is empty or if not list: checks if list is not empty
- while loop: use : and indentation
	- runs while a condition is True
	- flag: set to True when multiple conditions are all live, so while loop only checks if flag is True (not each condition)
	- break statement: exits while loop immediately, used with while True: loops
	- continue statement: skips rest of loop and goes back to the start
	- ctrl+C to exit infinite loop
	- use while list: to loop through all items in a list
	- use while 'item' in list: to loop through list until 

Object-oriented programming:
- effective approach where classes define general behaviour for a category of objects, objects based on classes with additional unique traits
- instantiation = making a specific object from a class, then using instance of a class to perform actions
- creating a class:
	- class Class_name:
		- definition with capitalisation for class name, e.g. class Dog:
	- a function that is part of a class is called a method
	- def __init__(self, par1, par2):
		- must use two trailing underscores on each side to ensure python calls it when class used
		- must include self as first parameter
			- reference to instance itself
			- gives instance access to attributes and methods in class
		- when creating an instance, don't need to pass self but need to pass par1 and par2
		- self.par1 = par1
			- makes the variable available to every method in class and to all instances
			- associates parameter par1 with variable par1 and attaches it to instance created
			- variables accessible through instances like this are called attributes
	- def function1(self, par3):
		- other methods must include self, and may include other parameters
		- available to instances
- creating an instance:
	- my_instance = Class_name(par1, par2) which calls __init__ method in the class itself > creates instance > assigns attributes
	- my_instance.par1 to access attributes
	- my_instance.method() to call a method from the related class
	- can create multiple instances which must have unique name or unique spot in list/dictionary

Types of errors:
- indentation
- logical
- syntax
- type e.g. when trying to change value in a tuple, or compare a string to an integer, call a function with wrong number of arguments
- key

Styling
- def function_name(par0, par1='default value')
- function_name(val0, par1='value')
- def function_name(
		par0, par1, par2,
		par3, par4, par5):
	function body...